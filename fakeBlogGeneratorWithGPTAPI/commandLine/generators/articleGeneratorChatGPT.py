import re
import openai
import time
import random


def generate_article(topic, person, api_key_GPT):
    openai.api_key = api_key_GPT
    query = f'Can you print a brief article concerning {topic} topic, the text should be 7 lines, with 4 words for SEO and a random date in the current year. The response should have this structure Date:,Category:,Title:,SEO:,Article:.  Each field has is own section, plus can the article be at least of 150 words? The name is {person}. The date should not be in the future'
    full_message = []
    full_message.append({'role': 'user', 'content': query})
    # Generates a random float value between 1 and 5 (inclusive) to avoid an error in the response of chatGPT
    delay = random.uniform(3, 6)
    time.sleep(delay)

    def article_generator_from_Chat_GPT(prompt, model="gpt-3.5-turbo"):
        response = openai.ChatCompletion.create(
            model=model,
            messages=prompt,
            max_tokens=700,
            n=1,
            stop=None,
            # Temperature is a parameter that controls the “creativity” or randomness of the text generated by GPT-3.5.
            temperature=1.2,
            # The range can be [0.5-2.0], suggest 1.2-1.4
        )

        print('This is the response: from the API-----')
        print(response)
        article = []
        message = response.choices[0].message.content.strip()
        print(message)

        date_match = re.search(r'(?:Date|Dates):\s*(.*)', message)
        category_match = re.search(r'Category:\s*(.*)', message)
        title_match = re.search(r'Title:\s*(.*)', message)
        seo_match = re.search(r'(?:SEO|Seo|SEO Keywords):\s*(.*)', message)
        text_match = re.search(
            r'(?:Article:|\*\*\*Article\*\*\*)\s*(.*)', message, re.DOTALL)

        # Retrieve the matched information
        date = date_match.group(1) if date_match else None
        category = category_match.group(1) if category_match else None
        title = title_match.group(1) if title_match else None
        seo = seo_match.group(1) if seo_match else None
        text = text_match.group(1) if text_match else None

        print('This is the text --------------')
        print(text)

        # Print the extracted information
        print("Date:", date)
        print("Category:", category)
        print("Title:", title)
        print("SEO:", seo)
        print("Article:", text)

        def uri_from_name(title):

            cleaned_title = re.sub(r'[^a-zA-Z0-9\s-]', '', title)
            # Replace spaces with hyphens and convert to lowercase
            uri = re.sub(r'\s+', '-', cleaned_title.strip().lower())

            return uri
        uri = uri_from_name(title)
        # print("This is the current URI: " + uri)

        # Sanitizing the article response from chatGPT, the function below handle the main text addition text by ChatGPT 
        textSanitized = text_sanitization(text)


        article.append(date)
        article.append(category)
        article.append(title)
        article.append(uri)
        article.append(seo)
        article.append(textSanitized)

        return article

    chatGPTResponse = article_generator_from_Chat_GPT(full_message)
    print(chatGPTResponse)
    return chatGPTResponse


result = ''


def generate_article_with_retries(topic, person, api_key_GPT, max_retries=3):
    '''
    Trial and error logic, in case there is an error from chatGPT regarding prompts limitations
    '''
    for _ in range(max_retries):
        try:
            # Call your function here
            result = generate_article(topic, person, api_key_GPT)
            return result  # Return the result if successful
        except Exception as e:
            print(f"An error occurred: {e}")

    print("Function couldn't generate article after retries.")
    return None


if result is not None:
    print("")
else:
    print("Article generation failed after retries.")


def text_sanitization(text):
    '''
    Sanitization of the special characters in case chatGPT print some random code in the response , plus normal sanitization
    '''
    substrings = ['}', '{', '/**', '_']

    for substring in substrings:
        if substring in text:
            raise Exception(
                'There is one of these characters in the response: }, {')
    # Remove content within parentheses with "Word count" or "Date" patterns
    text = re.sub(r'\(Word count:\s*\d+\)', '', text)
    text = re.sub(r'\(Word count:\s*\d+\)', '', text)
    text = re.sub(r'Overall Word.*', '', text)
    text = re.sub(r'Total words:.*', '', text)
    text = re.sub(r'\(Date:.*\n', '', text)
    text = re.sub(r'\(\d+.*', '', text)
    text = re.sub(r'\(Date:.*\n', '', text)
    text = re.sub(r'\(Note:.*\)', '', text, flags=re.DOTALL)
    text = re.sub(r'Name:.*', '', text, flags=re.DOTALL)
    text = re.sub(r'\(Article.*', ' ', text)
    text = re.sub(r'\(Please note:[^)]*\)', '', text)  # Remove "(Please note:" and its content

    # Remove content within square brackets with "Word count" pattern (case insensitive)
    text = re.sub(r'\[Word count:\s*\d+\]', '', text, flags=re.IGNORECASE)

    # Remove "Word count" and "Date" patterns (case insensitive)
    text = re.sub(r'Word count:\s*\d+', '', text, flags=re.IGNORECASE)
    text = re.sub(r'\(Word.counts:.\d+.*', '', text, flags=re.IGNORECASE)
    text = re.sub(r'Date:.*\n', '', text, flags=re.IGNORECASE)

    # Remove content after "Read more at::" (dotall flag used to match across lines)
    text = re.sub(r'Read more at::.*$', '', text, flags=re.DOTALL)

    # Remove "Note," "(Note:," or "Note to:" followed by any content (dotall flag used)
    text = re.sub(r'(?:Note|\(Note:|Note to):.*$', '', text, flags=re.DOTALL)

    # Remove hyphens
    text = text.replace('-', '')

    return text
